"""
MCP Server for comma-tools CTS-Lite API.

This server exposes the CTS-Lite analysis tools to AI assistants via the Model Context Protocol.
"""

import httpx
from typing import Any, Dict, List, Optional
from mcp.server.fastmcp import FastMCP

# Create MCP server
mcp = FastMCP("comma-tools")

# Default CTS-Lite API URL
DEFAULT_API_URL = "http://127.0.0.1:8080"


def get_api_url() -> str:
    """Get CTS-Lite API URL from environment or use default."""
    import os

    return os.getenv("CTS_LITE_URL", DEFAULT_API_URL)


def make_request(method: str, endpoint: str, **kwargs) -> Any:
    """Make HTTP request to CTS-Lite API with error handling."""
    url = f"{get_api_url()}{endpoint}"
    try:
        with httpx.Client(timeout=30.0) as client:
            response = client.request(method, url, **kwargs)
            response.raise_for_status()
            return response.json()
    except httpx.HTTPError as e:
        raise RuntimeError(f"API request failed: {e}")


@mcp.tool()
def check_health() -> Dict[str, Any]:
    """
    Check if CTS-Lite API server is healthy and get version information.

    Returns:
        Dictionary with status, version, and uptime information
    """
    return make_request("GET", "/v1/health")


@mcp.tool()
def get_version() -> Dict[str, Any]:
    """
    Get CTS-Lite API version and compatibility information.

    Returns:
        Dictionary with api_version, min_client_version, and deprecated_features
    """
    return make_request("GET", "/v1/version")


@mcp.tool()
def list_capabilities() -> Dict[str, Any]:
    """
    Get list of available analysis tools and their parameters.

    Returns:
        Dictionary with tools, monitors, and version information
    """
    return make_request("GET", "/v1/capabilities")


@mcp.tool()
def run_analysis(
    tool_id: str,
    file_path: Optional[str] = None,
    upload_id: Optional[str] = None,
    parameters: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Start an analysis run with the specified tool.

    Args:
        tool_id: ID of the tool to run (e.g., "rlog-to-csv", "can-bitwatch")
        file_path: Local file path to analyze (alternative to upload_id)
        upload_id: ID of previously uploaded file (alternative to file_path)
        parameters: Optional dictionary of tool-specific parameters

    Returns:
        Dictionary with run_id, status, and other run information

    Examples:
        >>> run_analysis("rlog-to-csv", file_path="/path/to/log.zst")
        >>> run_analysis("can-bitwatch", upload_id="abc123", parameters={"threshold": 5})
    """
    payload: Dict[str, Any] = {"tool_id": tool_id}

    if file_path:
        payload["file_path"] = file_path
    elif upload_id:
        payload["upload_id"] = upload_id
    else:
        raise ValueError("Must provide either file_path or upload_id")

    if parameters:
        payload["parameters"] = parameters

    return make_request("POST", "/v1/runs", json=payload)


@mcp.tool()
def get_run_status(run_id: str) -> Dict[str, Any]:
    """
    Get the status and details of a specific analysis run.

    Args:
        run_id: The unique ID of the run to query

    Returns:
        Dictionary with run status, progress, artifacts, and results
    """
    return make_request("GET", f"/v1/runs/{run_id}")


@mcp.tool()
def list_runs(status: Optional[str] = None, limit: int = 10) -> List[Dict[str, Any]]:
    """
    List recent analysis runs with optional status filtering.

    Args:
        status: Optional status filter ("pending", "running", "completed", "failed")
        limit: Maximum number of runs to return (default: 10)

    Returns:
        List of run dictionaries with id, tool_id, status, and timestamps
    """
    params = {"limit": limit}
    if status:
        params["status"] = status

    return make_request("GET", "/v1/runs", params=params)


@mcp.tool()
def list_artifacts(run_id: str) -> List[Dict[str, Any]]:
    """
    List all artifacts generated by a specific run.

    Args:
        run_id: The unique ID of the run

    Returns:
        List of artifact dictionaries with id, filename, size, and download URL
    """
    return make_request("GET", f"/v1/runs/{run_id}/artifacts")


@mcp.tool()
def get_artifact_content(artifact_id: str, max_size: int = 1000000) -> str:
    """
    Get the content of a text-based artifact (CSV, JSON, TXT, HTML).

    Args:
        artifact_id: The unique ID of the artifact
        max_size: Maximum file size to fetch in bytes (default: 1MB)

    Returns:
        String content of the artifact

    Note:
        This tool is best for text artifacts. For binary files, use download_artifact instead.
    """
    url = f"{get_api_url()}/v1/artifacts/{artifact_id}/content"
    try:
        with httpx.Client(timeout=30.0) as client:
            response = client.get(url)
            response.raise_for_status()

            # Check size
            content_length = int(response.headers.get("content-length", 0))
            if content_length > max_size:
                raise ValueError(
                    f"Artifact too large ({content_length} bytes > {max_size} limit)"
                )

            return response.text
    except httpx.HTTPError as e:
        raise RuntimeError(f"Failed to fetch artifact: {e}")


@mcp.tool()
def download_artifact(artifact_id: str, output_path: str) -> str:
    """
    Download an artifact to a local file.

    Args:
        artifact_id: The unique ID of the artifact
        output_path: Local path where the file should be saved

    Returns:
        Path to the downloaded file
    """
    url = f"{get_api_url()}/v1/artifacts/{artifact_id}/content"
    try:
        with httpx.Client(timeout=60.0) as client:
            response = client.get(url)
            response.raise_for_status()

            with open(output_path, "wb") as f:
                f.write(response.content)

            return output_path
    except (httpx.HTTPError, IOError) as e:
        raise RuntimeError(f"Failed to download artifact: {e}")


@mcp.tool()
def upload_file(file_path: str) -> Dict[str, Any]:
    """
    Upload a file to CTS-Lite for analysis.

    Args:
        file_path: Path to the local file to upload

    Returns:
        Dictionary with upload_id that can be used in run_analysis
    """
    try:
        with open(file_path, "rb") as f:
            files = {"file": f}
            return make_request("POST", "/v1/uploads", files=files)
    except IOError as e:
        raise RuntimeError(f"Failed to upload file: {e}")


# Resources: Expose common data
@mcp.resource("cts://config")
def get_server_config() -> str:
    """Get current CTS-Lite server configuration and status."""
    health = check_health()
    version = get_version()
    return f"""CTS-Lite Server Configuration:
- API URL: {get_api_url()}
- Status: {health.get('status', 'unknown')}
- Version: {health.get('version', 'unknown')}
- API Version: {version.get('api_version', 'unknown')}
- Uptime: {health.get('uptime', 'unknown')}
"""


@mcp.resource("cts://capabilities")
def get_capabilities_summary() -> str:
    """Get summary of available analysis tools."""
    caps = list_capabilities()
    tools = caps.get("tools", [])

    summary = "Available Analysis Tools:\n\n"
    for tool in tools:
        summary += f"- {tool.get('id', 'unknown')}: {tool.get('description', 'No description')}\n"
        params = tool.get("parameters", [])
        if params:
            summary += "  Parameters:\n"
            for param in params:
                required = " (required)" if param.get("required") else ""
                summary += f"    - {param.get('name')}: {param.get('description', '')}{required}\n"
        summary += "\n"

    return summary


if __name__ == "__main__":
    # Run the server
    mcp.run()